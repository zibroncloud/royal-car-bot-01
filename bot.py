import os
import logging
import sqlite3
from datetime import datetime, timedelta
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler
import asyncio

# Configurazione logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# Database setup
def init_db():
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    
    # Tabella utenti
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            telegram_id INTEGER PRIMARY KEY,
            name TEXT NOT NULL,
            role TEXT NOT NULL,
            active INTEGER DEFAULT 1
        )
    ''')
    
    # Tabella richieste
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS requests (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            targa TEXT NOT NULL,
            cliente TEXT NOT NULL,
            camera TEXT NOT NULL,
            servizio TEXT NOT NULL,
            stato TEXT DEFAULT 'nuovo',
            tempo_ritiro TEXT,
            tempo_riconsegna TEXT,
            partenza_confermata TIMESTAMP,
            arrivo_confermato TIMESTAMP,
            created_by INTEGER,
            assigned_to INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            completed_at TIMESTAMP,
            note TEXT
        )
    ''')
    
    # Tabella foto
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS photos (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            request_id INTEGER,
            file_id TEXT NOT NULL,
            tipo TEXT NOT NULL,
            uploaded_by INTEGER,
            uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (request_id) REFERENCES requests (id)
        )
    ''')
    
    conn.commit()
    conn.close()

# Inizializza database
init_db()

# Stati possibili
STATI = ['nuovo', 'assegnato', 'in_corso', 'partito', 'completato', 'in_riconsegna', 'riconsegnato', 'annullato']

# Funzioni database
def get_user_role(telegram_id):
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    cursor.execute('SELECT role FROM users WHERE telegram_id = ? AND active = 1', (telegram_id,))
    result = cursor.fetchone()
    conn.close()
    return result[0] if result else None

def add_user(telegram_id, name, role):
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT OR REPLACE INTO users (telegram_id, name, role, active) 
        VALUES (?, ?, ?, 1)
    ''', (telegram_id, name, role))
    conn.commit()
    conn.close()

def create_request(targa, cliente, camera, servizio, created_by):
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO requests (targa, cliente, camera, servizio, created_by)
        VALUES (?, ?, ?, ?, ?)
    ''', (targa.upper(), cliente, camera, servizio, created_by))
    request_id = cursor.lastrowid
    conn.commit()
    conn.close()
    return request_id

def get_requests(stato=None, search_term=None, assigned_to=None):
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    
    query = '''
        SELECT r.id, r.targa, r.cliente, r.camera, r.servizio, r.stato, 
               r.created_at, u1.name as created_by_name, u2.name as assigned_to_name,
               r.tempo_ritiro, r.tempo_riconsegna, r.partenza_confermata, r.arrivo_confermato
        FROM requests r
        LEFT JOIN users u1 ON r.created_by = u1.telegram_id
        LEFT JOIN users u2 ON r.assigned_to = u2.telegram_id
        WHERE 1=1
    '''
    params = []
    
    if stato:
        query += ' AND r.stato = ?'
        params.append(stato)
    
    if assigned_to:
        query += ' AND r.assigned_to = ?'
        params.append(assigned_to)
    
    if search_term:
        query += ' AND (r.targa LIKE ? OR r.cliente LIKE ?)'
        params.extend([f'%{search_term.upper()}%', f'%{search_term}%'])
    
    query += ' ORDER BY r.created_at DESC'
    
    cursor.execute(query, params)
    results = cursor.fetchall()
    conn.close()
    return results

def update_request_status(request_id, new_status, assigned_to=None, tempo_ritiro=None, tempo_riconsegna=None):
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    
    updates = ['stato = ?']
    params = [new_status]
    
    if assigned_to:
        updates.append('assigned_to = ?')
        params.append(assigned_to)
    
    if tempo_ritiro:
        updates.append('tempo_ritiro = ?')
        params.append(tempo_ritiro)
    
    if tempo_riconsegna:
        updates.append('tempo_riconsegna = ?')
        params.append(tempo_riconsegna)
    
    if new_status == 'partito':
        updates.append('partenza_confermata = CURRENT_TIMESTAMP')
    elif new_status == 'riconsegnato':
        updates.append('arrivo_confermato = CURRENT_TIMESTAMP')
        updates.append('completed_at = CURRENT_TIMESTAMP')
    
    params.append(request_id)
    
    query = f"UPDATE requests SET {', '.join(updates)} WHERE id = ?"
    cursor.execute(query, params)
    conn.commit()
    conn.close()

def add_photo(request_id, file_id, tipo, uploaded_by):
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO photos (request_id, file_id, tipo, uploaded_by)
        VALUES (?, ?, ?, ?)
    ''', (request_id, file_id, tipo, uploaded_by))
    conn.commit()
    conn.close()

def get_request_by_id(request_id):
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    cursor.execute('''
        SELECT r.*, u1.name as created_by_name, u2.name as assigned_to_name
        FROM requests r
        LEFT JOIN users u1 ON r.created_by = u1.telegram_id
        LEFT JOIN users u2 ON r.assigned_to = u2.telegram_id
        WHERE r.id = ?
    ''', (request_id,))
    result = cursor.fetchone()
    conn.close()
    return result

# Keyboards
def get_main_keyboard(role):
    if role == 'reception':
        keyboard = [
            [KeyboardButton("üÜï Nuova Richiesta")],
            [KeyboardButton("üìã Tutte le Richieste"), KeyboardButton("üîç Cerca")],
            [KeyboardButton("üìä Dashboard"), KeyboardButton("üöö Richiedi Riconsegna")],
            [KeyboardButton("‚ùì Help"), KeyboardButton("‚ùå Annulla")]
        ]
    else:  # valet
        keyboard = [
            [KeyboardButton("üìã Mie Richieste"), KeyboardButton("üÜï Richieste Nuove")],
            [KeyboardButton("üì∑ Aggiungi Foto"), KeyboardButton("‚úÖ Aggiorna Stato")],
            [KeyboardButton("‚ùì Help"), KeyboardButton("‚ùå Annulla")]
        ]
    
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

# Handlers
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    role = get_user_role(user.id)
    
    # Reset stato conversazione
    context.user_data.clear()
    
    if not role:
        await update.message.reply_text(
            "üöó *Benvenuto in RoyalCarBot01!*\n\n"
            "Per utilizzare questo bot, devi essere registrato.\n\n"
            "üìù *Comandi disponibili:*\n"
            "‚Ä¢ `/register <nome> reception` - Registrati come Reception\n"
            "‚Ä¢ `/register <nome> valet` - Registrati come Valet\n"
            "‚Ä¢ `/help` - Mostra tutti i comandi\n\n"
            "*Esempio:* `/register Mario reception`",
            parse_mode='Markdown'
        )
        return
    
    welcome_msg = f"üöó *Benvenuto {user.first_name}!*\n\n"
    if role == 'reception':
        welcome_msg += "Sei connesso come *Reception*\n"
        welcome_msg += "Puoi creare nuove richieste e gestire tutto il servizio valet."
    else:
        welcome_msg += "Sei connesso come *Valet*\n"
        welcome_msg += "Puoi vedere le tue richieste e aggiornare lo stato dei servizi."
    
    await update.message.reply_text(
        welcome_msg,
        reply_markup=get_main_keyboard(role),
        parse_mode='Markdown'
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    role = get_user_role(update.effective_user.id)
    
    if not role:
        help_text = """
‚ùì *HELP - RoyalCarBot01*

üìù *Registrazione:*
‚Ä¢ `/register <nome> reception` - Registrati come Reception
‚Ä¢ `/register <nome> valet` - Registrati come Valet

*Esempio:* `/register Mario reception`

üîß *Comandi Generali:*
‚Ä¢ `/start` - Avvia il bot e mostra menu
‚Ä¢ `/help` - Mostra questo messaggio
‚Ä¢ `/annulla` - Annulla operazione in corso

Per accedere alle funzioni complete, devi prima registrarti!
"""
    elif role == 'reception':
        help_text = """
‚ùì *HELP - RECEPTION*

üéØ *Menu Principale:*
‚Ä¢ üÜï *Nuova Richiesta* - Crea richiesta car valet
‚Ä¢ üìã *Tutte le Richieste* - Visualizza tutte le richieste
‚Ä¢ üîç *Cerca* - Cerca per targa o cognome
‚Ä¢ üìä *Dashboard* - Statistiche e riepilogo
‚Ä¢ üöö *Richiedi Riconsegna* - Richiedi riconsegna auto

üìù *Flusso Nuova Richiesta:*
1. Inserisci targa veicolo
2. Inserisci cognome cliente  
3. Inserisci numero camera
4. Scegli tipo servizio

üîß *Comandi:*
‚Ä¢ `/start` - Menu principale
‚Ä¢ `/help` - Mostra questo aiuto
‚Ä¢ `/annulla` - Annulla operazione
‚Ä¢ `/register <nome> <ruolo>` - Registra utente

üìã *Stati Richieste:*
üÜï Nuovo ‚Üí üë§ Assegnato ‚Üí ‚öôÔ∏è In Corso ‚Üí üöó Partito ‚Üí ‚úÖ Completato
"""
    else:  # valet
        help_text = """
‚ùì *HELP - VALET*

üéØ *Menu Principale:*
‚Ä¢ üìã *Mie Richieste* - Richieste assegnate a te
‚Ä¢ üÜï *Richieste Nuove* - Nuove richieste disponibili  
‚Ä¢ üì∑ *Aggiungi Foto* - Carica foto servizio
‚Ä¢ ‚úÖ *Aggiorna Stato* - Cambia stato richiesta

‚è∞ *Gestione Tempi:*
Quando prendi una richiesta, scegli:
‚Ä¢ Ritiro in 5 min ca.
‚Ä¢ Ritiro in 10 min ca.  
‚Ä¢ Ritiro in 20 min ca.

üì∑ *Caricamento Foto:*
Carica foto con didascalia: `#123 prima` o `#123 dopo`

üîß *Comandi:*
‚Ä¢ `/start` - Menu principale
‚Ä¢ `/help` - Mostra questo aiuto
‚Ä¢ `/annulla` - Annulla operazione

üìã *Stati che puoi gestire:*
üë§ Assegnato ‚Üí ‚öôÔ∏è In Corso ‚Üí üöó Partito ‚Üí ‚úÖ Completato
"""
    
    await update.message.reply_text(
        help_text, 
        parse_mode='Markdown',
        reply_markup=get_main_keyboard(role) if role else None
    )

async def cancel_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    role = get_user_role(update.effective_user.id)
    
    # Reset stato conversazione
    context.user_data.clear()
    
    if role:
        await update.message.reply_text(
            "‚ùå *Operazione annullata!*\n\nTorna al menu principale.",
            reply_markup=get_main_keyboard(role),
            parse_mode='Markdown'
        )
    else:
        await update.message.reply_text(
            "‚ùå Operazione annullata.\n\nUsa `/register <nome> <ruolo>` per registrarti."
        )

async def register_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args or len(context.args) != 2:
        await update.message.reply_text(
            "‚ùå *Formato sbagliato!*\n\n"
            "üìù *Uso corretto:*\n"
            "`/register <nome> <ruolo>`\n\n"
            "üé≠ *Ruoli disponibili:*\n"
            "‚Ä¢ `reception` - Reception hotel\n"
            "‚Ä¢ `valet` - Car valet staff\n\n"
            "üí° *Esempi:*\n"
            "‚Ä¢ `/register Mario reception`\n"
            "‚Ä¢ `/register Luca valet`",
            parse_mode='Markdown'
        )
        return
    
    name = context.args[0]
    role = context.args[1].lower()
    
    if role not in ['reception', 'valet']:
        await update.message.reply_text(
            "‚ùå *Ruolo non valido!*\n\n"
            "üé≠ *Ruoli disponibili:*\n"
            "‚Ä¢ `reception`\n" 
            "‚Ä¢ `valet`\n\n"
            "üí° *Esempio:* `/register Mario reception`",
            parse_mode='Markdown'
        )
        return
    
    add_user(update.effective_user.id, name, role)
    
    role_name = "Reception" if role == 'reception' else "Valet"
    await update.message.reply_text(
        f"‚úÖ *Registrazione completata!*\n\n"
        f"üë§ *Nome:* {name}\n"
        f"üé≠ *Ruolo:* {role_name}\n\n"
        f"Ora puoi utilizzare tutte le funzioni del bot!",
        reply_markup=get_main_keyboard(role),
        parse_mode='Markdown'
    )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    role = get_user_role(user.id)
    text = update.message.text
    
    if not role:
        await update.message.reply_text(
            "‚ö†Ô∏è Non sei registrato!\n\n"
            "Usa: `/register <nome> <ruolo>`\n"
            "Oppure `/help` per maggiori informazioni."
        )
        return
    
    # Gestione stati conversazione
    if context.user_data.get('state') == 'creating_request':
        await handle_new_request_data(update, context)
        return
    
    if context.user_data.get('state') == 'searching':
        await handle_search(update, context)
        return
    
    if context.user_data.get('state') == 'requesting_delivery':
        await handle_delivery_request(update, context)
        return
    
    # Menu principale
    if text == "üÜï Nuova Richiesta" and role == 'reception':
        context.user_data['state'] = 'creating_request'
        context.user_data['request_data'] = {}
        await update.message.reply_text(
            "üöó *Nuova Richiesta Car Valet*\n\n"
            "Inserisci la *targa* del veicolo:\n\n"
            "üí° *Suggerimento:* Usa formato ABC123 o AB123CD",
            parse_mode='Markdown'
        )
    
    elif text == "üìã Tutte le Richieste":
        await show_all_requests(update, context)
    
    elif text == "üîç Cerca":
        context.user_data['state'] = 'searching'
        await update.message.reply_text(
            "üîç *Ricerca Richieste*\n\n"
            "Inserisci:\n"
            "‚Ä¢ Targa del veicolo\n"
            "‚Ä¢ Cognome del cliente\n"
            "‚Ä¢ Numero camera",
            parse_mode='Markdown'
        )
    
    elif text == "üöö Richiedi Riconsegna" and role == 'reception':
        context.user_data['state'] = 'requesting_delivery'
        await update.message.reply_text(
            "üöö *Richiesta Riconsegna*\n\n"
            "Inserisci la *targa* del veicolo da riconsegnare:",
            parse_mode='Markdown'
        )
    
    elif text == "üìã Mie Richieste" and role == 'valet':
        await show_valet_requests(update, context)
    
    elif text == "üÜï Richieste Nuove" and role == 'valet':
        await show_new_requests(update, context)
    
    elif text == "üìä Dashboard" and role == 'reception':
        await show_dashboard(update, context)
    
    elif text == "‚ùì Help":
        await help_command(update, context)
    
    elif text == "‚ùå Annulla":
        await cancel_command(update, context)
    
    else:
        await update.message.reply_text(
            "‚ùì *Comando non riconosciuto*\n\n"
            "Usa i pulsanti del menu o `/help` per vedere tutti i comandi disponibili.",
            parse_mode='Markdown'
        )

async def handle_new_request_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    request_data = context.user_data.get('request_data', {})
    
    if 'targa' not in request_data:
        request_data['targa'] = text.upper()
        context.user_data['request_data'] = request_data
        await update.message.reply_text(
            "üë§ *Dati Cliente*\n\n"
            "Inserisci il *cognome del cliente*:",
            parse_mode='Markdown'
        )
    
    elif 'cliente' not in request_data:
        request_data['cliente'] = text
        context.user_data['request_data'] = request_data
        await update.message.reply_text(
            "üè® *Dettagli Soggiorno*\n\n"
            "Inserisci il *numero della camera*:",
            parse_mode='Markdown'
        )
    
    elif 'camera' not in request_data:
        request_data['camera'] = text
        context.user_data['request_data'] = request_data
        
        # Keyboard per tipo servizio
        keyboard = [
            [InlineKeyboardButton("üßΩ Lavaggio Esterno", callback_data="servizio_lavaggio_esterno")],
            [InlineKeyboardButton("üßº Lavaggio Completo", callback_data="servizio_lavaggio_completo")],
            [InlineKeyboardButton("üîß Servizio Meccanico", callback_data="servizio_meccanico")],
            [InlineKeyboardButton("‚õΩ Rifornimento", callback_data="servizio_rifornimento")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            "üîß *Tipo di Servizio*\n\n"
            "Seleziona il servizio richiesto:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

async def handle_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    search_term = update.message.text
    requests = get_requests(search_term=search_term)
    
    context.user_data['state'] = None
    
    if not requests:
        await update.message.reply_text(
            f"‚ùå *Nessuna richiesta trovata*\n\n"
            f"üîç Termine cercato: `{search_term}`\n\n"
            f"üí° Prova con:\n"
            f"‚Ä¢ Targa completa o parziale\n"
            f"‚Ä¢ Cognome cliente\n"
            f"‚Ä¢ Numero camera",
            parse_mode='Markdown',
            reply_markup=get_main_keyboard(get_user_role(update.effective_user.id))
        )
        return
    
    message = f"üîç *Risultati ricerca: {search_term}*\n\n"
    for req in requests:
        status_emoji = {
            'nuovo': 'üÜï', 'assegnato': 'üë§', 'in_corso': '‚öôÔ∏è', 
            'partito': 'üöó', 'completato': '‚úÖ', 'riconsegnato': 'üèÅ', 'annullato': '‚ùå'
        }
        
        message += f"{status_emoji.get(req[5], 'üìã')} *#{req[0]}* - {req[1]}\n"
        message += f"üë§ {req[2]} | üè® Camera {req[3]}\n"
        message += f"üîß {req[4]} | üìä {req[5].upper()}\n"
        if req[8]:  # assigned_to_name
            message += f"üë®‚Äçüîß Valet: {req[8]}\n"
        if req[9]:  # tempo_ritiro
            message += f"‚è∞ Ritiro: {req[9]}\n"
        message += f"üìÖ {req[6][:16]}\n\n"
    
    await update.message.reply_text(
        message,
        parse_mode='Markdown',
        reply_markup=get_main_keyboard(get_user_role(update.effective_user.id))
    )

async def handle_delivery_request(update: Update, context: ContextTypes.DEFAULT_TYPE):
    targa = update.message.text.upper()
    context.user_data['state'] = None
    
    # Trova richiesta per targa
    requests = get_requests(search_term=targa)
    completed_requests = [r for r in requests if r[5] in ['completato', 'riconsegnato']]
    
    if not completed_requests:
        await update.message.reply_text(
            f"‚ùå *Nessun veicolo trovato*\n\n"
            f"üöó Targa: `{targa}`\n\n"
            f"Verifica che:\n"
            f"‚Ä¢ La targa sia corretta\n"
            f"‚Ä¢ Il servizio sia completato",
            parse_mode='Markdown',
            reply_markup=get_main_keyboard(get_user_role(update.effective_user.id))
        )
        return
    
    # Prendi la richiesta pi√π recente completata
    req = completed_requests[0]
    
    if not req[8]:  # assigned_to_name
        await update.message.reply_text(
            f"‚ùå *Errore*\n\n"
            f"Nessun valet assegnato per il veicolo `{targa}`",
            parse_mode='Markdown',
            reply_markup=get_main_keyboard(get_user_role(update.effective_user.id))
        )
        return
    
    # Invia notifica al valet per riconsegna
    await notify_valet_for_delivery(context, req)
    
    await update.message.reply_text(
        f"‚úÖ *Richiesta riconsegna inviata!*\n\n"
        f"üöó Targa: `{req[1]}`\n"
        f"üë§ Cliente: {req[2]}\n"
        f"üè® Camera: {req[3]}\n"
        f"üë®‚Äçüîß Valet: {req[8]}\n\n"
        f"Il valet ricever√† la notifica per la riconsegna.",
        parse_mode='Markdown',
        reply_markup=get_main_keyboard(get_user_role(update.effective_user.id))
    )

async def show_all_requests(update: Update, context: ContextTypes.DEFAULT_TYPE):
    requests = get_requests()
    
    if not requests:
        await update.message.reply_text(
            "üìã *Nessuna richiesta presente*\n\n"
            "Usa 'üÜï Nuova Richiesta' per creare la prima richiesta!",
            parse_mode='Markdown'
        )
        return
    
    message = "üìã *Tutte le Richieste*\n\n"
    for req in requests:
        status_emoji = {
            'nuovo': 'üÜï', 'assegnato': 'üë§', 'in_corso': '‚öôÔ∏è', 
            'partito': 'üöó', 'completato': '‚úÖ', 'riconsegnato': 'üèÅ', 'annullato': '‚ùå'
        }
        
        message += f"{status_emoji.get(req[5], 'üìã')} *#{req[0]}* - {req[1]}\n"
        message += f"üë§ {req[2]} | üè® {req[3]}\n"
        message += f"üîß {req[4]} | üìä {req[5].upper()}\n"
        if req[8]:  # assigned_to_name
            message += f"üë®‚Äçüîß {req[8]}\n"
        if req[9]:  # tempo_ritiro
            message += f"‚è∞ Ritiro: {req[9]}\n"
        if req[10]:  # tempo_riconsegna
            message += f"üöö Riconsegna: {req[10]}\n"
        message += f"üìÖ {req[6][:16]}\n\n"
    
    await update.message.reply_text(message, parse_mode='Markdown')

async def show_valet_requests(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    requests = get_requests(assigned_to=user_id)
    active_requests = [r for r in requests if r[5] not in ['riconsegnato', 'annullato']]
    
    if not active_requests:
        await update.message.reply_text(
            "üìã *Nessuna richiesta assegnata*\n\n"
            "Usa 'üÜï Richieste Nuove' per vedere le richieste disponibili!",
            parse_mode='Markdown'
        )
        return
    
    message = "üìã *Le Tue Richieste*\n\n"
    keyboard = []
    
    for req in active_requests:
        status_emoji = {
            'assegnato': 'üë§', 'in_corso': '‚öôÔ∏è', 'partito': 'üöó', 'completato': '‚úÖ'
        }
        
        message += f"{status_emoji.get(req[5], 'üìã')} *#{req[0]}* - {req[1]}\n"
        message += f"üë§ {req[2]} | üè® {req[3]}\n"
        message += f"üîß {req[4]} | üìä {req[5].upper()}\n"
        if req[9]:  # tempo_ritiro
            message += f"‚è∞ Ritiro: {req[9]}\n"
        if req[10]:  # tempo_riconsegna  
            message += f"üöö Riconsegna: {req[10]}\n"
        message += f"üìÖ {req[6][:16]}\n\n"
        
        keyboard.append([InlineKeyboardButton(
            f"üöó Prendi #{req[0]}", 
            callback_data=f"assign_{req[0]}"
        )])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        message, 
        parse_mode='Markdown',
        reply_markup=reply_markup
    )

async def show_dashboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    
    # Statistiche
    cursor.execute('SELECT COUNT(*) FROM requests WHERE stato = "nuovo"')
    nuove = cursor.fetchone()[0]
    
    cursor.execute('SELECT COUNT(*) FROM requests WHERE stato IN ("assegnato", "in_corso", "partito")')
    in_corso = cursor.fetchone()[0]
    
    cursor.execute('SELECT COUNT(*) FROM requests WHERE stato = "completato"')
    completate = cursor.fetchone()[0]
    
    cursor.execute('SELECT COUNT(*) FROM requests WHERE DATE(created_at) = DATE("now")')
    oggi = cursor.fetchone()[0]
    
    cursor.execute('SELECT COUNT(*) FROM requests')
    totali = cursor.fetchone()[0]
    
    conn.close()
    
    message = f"üìä *Dashboard RoyalCarBot01*\n\n"
    message += f"üÜï Richieste nuove: *{nuove}*\n"
    message += f"‚öôÔ∏è In lavorazione: *{in_corso}*\n"
    message += f"‚úÖ Completate: *{completate}*\n"
    message += f"üìÖ Richieste oggi: *{oggi}*\n"
    message += f"üìà Totale richieste: *{totali}*\n\n"
    message += f"üïê Ultimo aggiornamento: {datetime.now().strftime('%H:%M')}"
    
    await update.message.reply_text(message, parse_mode='Markdown')

async def handle_callback_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    data = query.data
    user_id = update.effective_user.id
    role = get_user_role(user_id)
    
    # Gestione selezione servizio
    if data.startswith('servizio_'):
        servizio = data.replace('servizio_', '').replace('_', ' ').title()
        request_data = context.user_data.get('request_data', {})
        request_data['servizio'] = servizio
        
        # Crea la richiesta
        request_id = create_request(
            request_data['targa'],
            request_data['cliente'],
            request_data['camera'],
            request_data['servizio'],
            user_id
        )
        
        # Reset stato
        context.user_data['state'] = None
        context.user_data['request_data'] = {}
        
        await query.edit_message_text(
            f"‚úÖ *Richiesta #{request_id} creata!*\n\n"
            f"üöó Targa: `{request_data['targa']}`\n"
            f"üë§ Cliente: {request_data['cliente']}\n"
            f"üè® Camera: {request_data['camera']}\n"
            f"üîß Servizio: {servizio}\n\n"
            f"La richiesta √® stata inviata al team valet! üöÄ",
            parse_mode='Markdown'
        )
        
        # Notifica ai valet
        await notify_valets(context, request_id, request_data)
    
    # Gestione presa in carico con scelta tempi
    elif data.startswith('assign_'):
        request_id = int(data.split('_')[1])
        
        keyboard = [
            [InlineKeyboardButton("‚è±Ô∏è Ritiro in 5 min ca.", callback_data=f"pickup_{request_id}_5")],
            [InlineKeyboardButton("‚è±Ô∏è Ritiro in 10 min ca.", callback_data=f"pickup_{request_id}_10")],
            [InlineKeyboardButton("‚è±Ô∏è Ritiro in 20 min ca.", callback_data=f"pickup_{request_id}_20")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            f"‚è∞ *Tempo stimato per il ritiro?*\n\n"
            f"Richiesta #{request_id}\n"
            f"Seleziona il tempo stimato per raggiungere l'hotel:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    # Gestione conferma ritiro con tempo
    elif data.startswith('pickup_'):
        parts = data.split('_')
        request_id = int(parts[1])
        minutes = parts[2]
        
        tempo_text = f"{minutes} min ca."
        update_request_status(request_id, 'assegnato', user_id, tempo_ritiro=tempo_text)
        
        req = get_request_by_id(request_id)
        
        await query.edit_message_text(
            f"‚úÖ *Richiesta #{request_id} presa in carico!*\n\n"
            f"‚è∞ Tempo stimato ritiro: *{tempo_text}*\n\n"
            f"üöó {req[1]} - {req[2]}\n"
            f"üè® Camera {req[3]}\n"
            f"üîß {req[4]}\n\n"
            f"Ora puoi aggiornare lo stato quando parti dall'hotel.",
            parse_mode='Markdown'
        )
        
        # Notifica reception
        await notify_reception_assignment(context, request_id, req, tempo_text)
    
    # Gestione richieste valet
    elif data.startswith('manage_'):
        request_id = int(data.split('_')[1])
        req = get_request_by_id(request_id)
        
        if not req:
            await query.edit_message_text("‚ùå Richiesta non trovata.")
            return
        
        keyboard = []
        
        if req[5] == 'assegnato':
            keyboard.extend([
                [InlineKeyboardButton("üöó Inizia Servizio", callback_data=f"status_{request_id}_in_corso")],
                [InlineKeyboardButton("üèÉ‚Äç‚ôÇÔ∏è Sono Partito", callback_data=f"status_{request_id}_partito")]
            ])
        elif req[5] == 'in_corso':
            keyboard.append([InlineKeyboardButton("‚úÖ Servizio Completato", callback_data=f"status_{request_id}_completato")])
        elif req[5] == 'completato':
            keyboard.append([InlineKeyboardButton("üöö Richiedi Riconsegna", callback_data=f"request_delivery_{request_id}")])
        
        keyboard.append([InlineKeyboardButton("‚ùå Annulla Richiesta", callback_data=f"status_{request_id}_annullato")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        status_emoji = {
            'assegnato': 'üë§', 'in_corso': '‚öôÔ∏è', 'partito': 'üöó', 'completato': '‚úÖ'
        }
        
        message = f"{status_emoji.get(req[5], 'üìã')} *Richiesta #{request_id}*\n\n"
        message += f"üöó Targa: `{req[1]}`\n"
        message += f"üë§ Cliente: {req[2]}\n"
        message += f"üè® Camera: {req[3]}\n"
        message += f"üîß Servizio: {req[4]}\n"
        message += f"üìä Stato: {req[5].upper()}\n"
        if req[9]:  # tempo_ritiro
            message += f"‚è∞ Ritiro: {req[9]}\n"
        if req[10]:  # tempo_riconsegna
            message += f"üöö Riconsegna: {req[10]}\n"
        
        await query.edit_message_text(
            message,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    # Gestione cambio stato
    elif data.startswith('status_'):
        parts = data.split('_')
        request_id = int(parts[1])
        new_status = parts[2]
        
        update_request_status(request_id, new_status)
        
        status_names = {
            'in_corso': 'In Corso ‚öôÔ∏è',
            'partito': 'Partito üöó',
            'completato': 'Completato ‚úÖ',
            'annullato': 'Annullato ‚ùå'
        }
        
        await query.edit_message_text(
            f"‚úÖ *Stato aggiornato!*\n\n"
            f"Richiesta #{request_id}: {status_names[new_status]}\n\n"
            f"‚è∞ Aggiornato alle {datetime.now().strftime('%H:%M')}"
        )
        
        # Notifiche specifiche
        if new_status == 'partito':
            req = get_request_by_id(request_id)
            await notify_reception_departure(context, request_id, req)
        elif new_status == 'completato':
            await notify_reception_completion(context, request_id)
    
    # Richiesta riconsegna dal valet
    elif data.startswith('request_delivery_'):
        request_id = int(data.split('_')[2])
        
        keyboard = [
            [InlineKeyboardButton("üöö Riconsegna in 10 min", callback_data=f"delivery_{request_id}_10")],
            [InlineKeyboardButton("üöö Riconsegna in 20 min", callback_data=f"delivery_{request_id}_20")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            f"üöö *Richiesta Riconsegna*\n\n"
            f"Quanto tempo ti serve per la riconsegna?",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    # Gestione riconsegna dal valet
    elif data.startswith('delivery_'):
        parts = data.split('_')
        request_id = int(parts[1])
        minutes = parts[2]
        
        tempo_text = f"{minutes} min ca."
        update_request_status(request_id, 'in_riconsegna', tempo_riconsegna=tempo_text)
        
        req = get_request_by_id(request_id)
        
        await query.edit_message_text(
            f"‚úÖ *Riconsegna programmata!*\n\n"
            f"üöö Tempo stimato: *{tempo_text}*\n"
            f"üöó {req[1]} - {req[2]}\n"
            f"üè® Camera {req[3]}\n\n"
            f"La reception √® stata avvisata.",
            parse_mode='Markdown'
        )
        
        # Notifica reception
        await notify_reception_delivery_time(context, request_id, req, tempo_text)
    
    # Conferma riconsegna da reception
    elif data.startswith('confirm_delivery_'):
        request_id = int(data.split('_')[2])
        
        update_request_status(request_id, 'riconsegnato')
        
        await query.edit_message_text(
            f"‚úÖ *Riconsegna confermata!*\n\n"
            f"Richiesta #{request_id} completata con successo!\n"
            f"‚è∞ Completata alle {datetime.now().strftime('%H:%M')}"
        )

async def notify_valets(context, request_id, request_data):
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    cursor.execute('SELECT telegram_id, name FROM users WHERE role = "valet" AND active = 1')
    valets = cursor.fetchall()
    conn.close()
    
    message = f"üÜï *Nuova Richiesta #{request_id}*\n\n"
    message += f"üöó Targa: `{request_data['targa']}`\n"
    message += f"üë§ Cliente: {request_data['cliente']}\n"
    message += f"üè® Camera: {request_data['camera']}\n"
    message += f"üîß Servizio: {request_data['servizio']}\n\n"
    message += "Usa il menu 'üÜï Richieste Nuove' per prendere in carico!"
    
    for valet_id, valet_name in valets:
        try:
            await context.bot.send_message(
                chat_id=valet_id,
                text=message,
                parse_mode='Markdown'
            )
        except Exception as e:
            logging.error(f"Errore invio notifica a valet {valet_id}: {e}")

async def notify_reception_assignment(context, request_id, req, tempo_text):
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    cursor.execute('SELECT telegram_id FROM users WHERE role = "reception" AND active = 1')
    reception_users = cursor.fetchall()
    conn.close()
    
    message = f"üë§ *Richiesta #{request_id} Assegnata*\n\n"
    message += f"üöó Targa: `{req[1]}`\n"
    message += f"üë§ Cliente: {req[2]}\n"
    message += f"üè® Camera: {req[3]}\n"
    message += f"üë®‚Äçüîß Valet: {req[14]}\n"  # assigned_to_name
    message += f"‚è∞ Tempo ritiro: {tempo_text}\n\n"
    message += "Il valet raggiunger√† l'hotel nel tempo indicato."
    
    for reception_id, in reception_users:
        try:
            await context.bot.send_message(
                chat_id=reception_id,
                text=message,
                parse_mode='Markdown'
            )
        except Exception as e:
            logging.error(f"Errore invio notifica a reception {reception_id}: {e}")

async def notify_reception_departure(context, request_id, req):
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    cursor.execute('SELECT telegram_id FROM users WHERE role = "reception" AND active = 1')
    reception_users = cursor.fetchall()
    conn.close()
    
    message = f"üöó *Valet in Arrivo #{request_id}*\n\n"
    message += f"üöó Targa: `{req[1]}`\n"
    message += f"üë§ Cliente: {req[2]}\n"
    message += f"üè® Camera: {req[3]}\n"
    message += f"üë®‚Äçüîß Valet: {req[14]}\n"  # assigned_to_name
    message += f"‚è∞ Partito alle: {datetime.now().strftime('%H:%M')}\n\n"
    message += "Il valet √® in arrivo per il ritiro del veicolo!"
    
    for reception_id, in reception_users:
        try:
            await context.bot.send_message(
                chat_id=reception_id,
                text=message,
                parse_mode='Markdown'
            )
        except Exception as e:
            logging.error(f"Errore invio notifica a reception {reception_id}: {e}")

async def notify_reception_completion(context, request_id):
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    
    cursor.execute('''
        SELECT r.targa, r.cliente, r.camera, r.servizio, u.name
        FROM requests r
        LEFT JOIN users u ON r.assigned_to = u.telegram_id
        WHERE r.id = ?
    ''', (request_id,))
    req = cursor.fetchone()
    
    cursor.execute('SELECT telegram_id FROM users WHERE role = "reception" AND active = 1')
    reception_users = cursor.fetchall()
    conn.close()
    
    if not req:
        return
    
    message = f"‚úÖ *Servizio Completato #{request_id}*\n\n"
    message += f"üöó Targa: `{req[0]}`\n"
    message += f"üë§ Cliente: {req[1]}\n"
    message += f"üè® Camera: {req[2]}\n"
    message += f"üîß Servizio: {req[3]}\n"
    message += f"üë®‚Äçüîß Valet: {req[4]}\n"
    message += f"‚è∞ Completato alle: {datetime.now().strftime('%H:%M')}\n\n"
    message += "Il veicolo √® pronto! Usa 'üöö Richiedi Riconsegna' quando necessario."
    
    for reception_id, in reception_users:
        try:
            await context.bot.send_message(
                chat_id=reception_id,
                text=message,
                parse_mode='Markdown'
            )
        except Exception as e:
            logging.error(f"Errore invio notifica a reception {reception_id}: {e}")

async def notify_valet_for_delivery(context, req):
    valet_id = None
    
    # Trova l'ID del valet dalla richiesta
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    cursor.execute('SELECT assigned_to FROM requests WHERE id = ?', (req[0],))
    result = cursor.fetchone()
    if result:
        valet_id = result[0]
    conn.close()
    
    if not valet_id:
        return
    
    keyboard = [
        [InlineKeyboardButton("‚úÖ Messaggio Visualizzato", callback_data=f"delivery_ack_{req[0]}")],
        [InlineKeyboardButton("üöö Riconsegna in 10 min", callback_data=f"delivery_{req[0]}_10")],
        [InlineKeyboardButton("üöö Riconsegna in 20 min", callback_data=f"delivery_{req[0]}_20")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    message = f"üöö *Richiesta Riconsegna #{req[0]}*\n\n"
    message += f"üöó Targa: `{req[1]}`\n"
    message += f"üë§ Cliente: {req[2]}\n"
    message += f"üè® Camera: {req[3]}\n\n"
    message += "La reception richiede la riconsegna del veicolo.\n"
    message += "Conferma la visualizzazione e indica i tempi!"
    
    try:
        await context.bot.send_message(
            chat_id=valet_id,
            text=message,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    except Exception as e:
        logging.error(f"Errore invio notifica riconsegna a valet {valet_id}: {e}")

async def notify_reception_delivery_time(context, request_id, req, tempo_text):
    conn = sqlite3.connect('royal_car_bot.db')
    cursor = conn.cursor()
    cursor.execute('SELECT telegram_id FROM users WHERE role = "reception" AND active = 1')
    reception_users = cursor.fetchall()
    conn.close()
    
    keyboard = [[InlineKeyboardButton("‚úÖ Riconsegna Avvenuta", callback_data=f"confirm_delivery_{request_id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    message = f"üöö *Riconsegna Programmata #{request_id}*\n\n"
    message += f"üöó Targa: `{req[1]}`\n"
    message += f"üë§ Cliente: {req[2]}\n"
    message += f"üè® Camera: {req[3]}\n"
    message += f"üë®‚Äçüîß Valet: {req[14]}\n"  # assigned_to_name
    message += f"‚è∞ Tempo stimato: {tempo_text}\n\n"
    message += "Il valet arriver√† per la riconsegna nel tempo indicato.\n"
    message += "Clicca il pulsante quando la riconsegna √® avvenuta!"
    
    for reception_id, in reception_users:
        try:
            await context.bot.send_message(
                chat_id=reception_id,
                text=message,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        except Exception as e:
            logging.error(f"Errore invio notifica a reception {reception_id}: {e}")

async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    role = get_user_role(user_id)
    
    if not role:
        return
    
    # Gestisci foto con caption che indica l'ID richiesta
    caption = update.message.caption
    if caption and caption.startswith('#'):
        try:
            request_id = int(caption[1:].split()[0])
            file_id = update.message.photo[-1].file_id
            
            # Determina tipo foto
            tipo = 'prima' if 'prima' in caption.lower() else 'dopo'
            
            add_photo(request_id, file_id, tipo, user_id)
            
            await update.message.reply_text(
                f"üì∑ *Foto aggiunta!*\n\n"
                f"Foto {tipo} per richiesta #{request_id}\n"
                f"‚è∞ Caricata alle {datetime.now().strftime('%H:%M')}",
                parse_mode='Markdown'
            )
            
        except (ValueError, IndexError):
            await update.message.reply_text(
                "‚ùå *Formato didascalia non valido*\n\n"
                "üìù *Formato corretto:*\n"
                "`#ID_RICHIESTA prima` o `#ID_RICHIESTA dopo`\n\n"
                "üí° *Esempi:*\n"
                "‚Ä¢ `#123 prima`\n"
                "‚Ä¢ `#123 dopo`",
                parse_mode='Markdown'
            )
    else:
        await update.message.reply_text(
            "üì∑ *Come caricare le foto*\n\n"
            "Per associare la foto ad una richiesta,\n"
            "aggiungi come didascalia:\n\n"
            "`#ID_RICHIESTA prima` o `#ID_RICHIESTA dopo`\n\n"
            "üí° *Esempio:* `#123 prima`",
            parse_mode='Markdown'
        )

def main():
    # Token del bot (da impostare nelle variabili d'ambiente)
    TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
    
    if not TOKEN:
        print("‚ùå ERRORE: TELEGRAM_BOT_TOKEN non impostato!")
        return
    
    # Crea applicazione
    application = Application.builder().token(TOKEN).build()
    
    # Aggiungi handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("annulla", cancel_command))
    application.add_handler(CommandHandler("register", register_user))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(MessageHandler(filters.PHOTO, handle_photo))
    application.add_handler(CallbackQueryHandler(handle_callback_query))
    
    # Avvia bot
    print("ü§ñ RoyalCarBot01 avviato!")
    print("üìã Nuove funzionalit√†:")
    print("   ‚úÖ Comando /help completo")
    print("   ‚úÖ Comando /annulla")
    print("   ‚úÖ Gestione tempi ritiro/riconsegna")
    print("   ‚úÖ Notifiche automatiche con orari")
    print("   ‚úÖ Menu pulsanti sempre visibili")
    print("   ‚úÖ Messaggi di conferma migliorati")
    
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()dButton(
            f"‚öôÔ∏è Gestisci #{req[0]}", 
            callback_data=f"manage_{req[0]}"
        )))
    
    reply_markup = InlineKeyboardMarkup(keyboard) if keyboard else None
    
    await update.message.reply_text(
        message, 
        parse_mode='Markdown',
        reply_markup=reply_markup
    )

async def show_new_requests(update: Update, context: ContextTypes.DEFAULT_TYPE):
    requests = get_requests(stato='nuovo')
    
    if not requests:
        await update.message.reply_text(
            "üÜï *Nessuna nuova richiesta*\n\n"
            "Al momento non ci sono richieste disponibili.",
            parse_mode='Markdown'
        )
        return
    
    message = "üÜï *Nuove Richieste Disponibili*\n\n"
    keyboard = []
    
    for req in requests:
        message += f"üÜî *#{req[0]}* - {req[1]}\n"
        message += f"üë§ {req[2]} | üè® {req[3]}\n"
        message += f"üîß {req[4]}\n"
        message += f"üìÖ {req[6][:16]}\n\n"
        
        keyboard.append([InlineKeyboar
